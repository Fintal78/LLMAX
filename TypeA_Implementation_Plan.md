# Comprehensive Implementation Plan: The "Subscore" Architecture

## 1. Deep Analysis of `scoring_rules.md` Logic
After zooming out and thoroughly re-evaluating the 70+ subsections in `scoring_rules.md`, it is evident that the scoring mechanics operate on a strict, multi-tiered mathematical hierarchy:

1. **The Sub-Component Level (The Input):** Specific hardware criteria evaluated individually (e.g., 1.2.A Dust Protection, 4.13.1 Professional Codec, 6.3.1 Base GPU Architecture). Each of these sub-components evaluates a raw physical specification against a lookup table or sub-formula, generating an intermediate numerical value.
2. **The Subsection Level (The Output):** The parent category (e.g., 1.2 Durability, 4.13 Video Encoding, 6.3 GPU Performance) aggregates the various sub-components using weighted formulas to produce the **Predicted Score** (and ultimately the **Final Score** if a benchmark/booster applies).

## 2. The Flaw in the Current Data Structure
My previous analysis was too superficial because it only focused on the *storage of the string* rather than the *pipeline of the logic*. 

The current JSON schema defines a `Type A` component as just three fields: `value`, `source`, `exact_extract`. At the absolute bottom of the subsection, it spits out the consolidated `scores` object (`predicted`, `final`).

**The Missing Link:** The intermediate mathematical step is entirely lost in the JSON. If "Dust Protection" evaluates to 6 (IP6x), we lose the fact that this specific integer translates to an intermediate score of 10.0 before it is averaged with Water Protection. 

In the flawed `4.13` example, I awkwardly contorted the JSON to include `is_supported` because I was subconsciously trying to separate "the physics" from "the rule condition" inside the Type A block, completely missing that what I really needed was a dedicated field for the sub-score outcome.

## 3. The Proposal: The `subscore` Integration
To resolve this elegantly, we must explicitly distinguish `"value"` (the raw physical reality, which can embody anything from text to a list of integers) from the mathematical evaluation of that reality. 

I propose updating **all Data Structure Types (A, B, and C)** to officially support and mandate a `"subscore"` field at the sub-component level.

### Why `subscore`?
It explicitly differentiates intermediate step calculations from the `"real"` output scores (`predicted` and `final`) which sit at the root of the subsection. This ensures anyone reading the JSON can follow the math line-by-line without opening the rulebook.

### 3.1 Type A: Raw External Data (Updated)
A Type A object represents a physical hardware spec and its direct mathematical evaluation.
- `"value"`: The raw technical truth (e.g., "ProRes 4K60", or "Titanium Alloy").
- `"source"` & `"exact_extract"`: The verbatim proof.
- `"subscore"`: The 0-10 score generated by feeding the `"value"` into the specific sub-rule table (e.g., Rule 4.13.1).

**Example: 4.13 Video Encoding**
```json
"4_13_video_encoding": {
  "professional_codec_support": {
    "value": "ProRes 4K60",
    "source": "https://www.gsmarena.com/apple_iphone_15_pro-12557.php",
    "exact_extract": "ProRes",
    "subscore": 10.0  // Evaluated via Rule 4.13.1
  },
  "log_color_profile": {
    "value": "Apple Log",
    "source": "https://www.gsmarena.com/apple_iphone_15_pro-12557.php",
    "exact_extract": "Log",
    "subscore": 10.0  // Evaluated via Rule 4.13.2
  },
  "color_bit_depth": {
    "value": 10,
    "source": "https://www.gsmarena.com/apple_iphone_15_pro-12557.php",
    "exact_extract": "10-bit HDR",
    "subscore": 10.0  // Evaluated via Rule 4.13.3
  },
  "scores": {
    "predicted": 10.0, // Aggregated: (0.4 * 10) + (0.35 * 10) + (0.25 * 10)
    "final": { ... }
  }
}
```

### 3.2 Type B: Internal Reference (Updated)
Type B imports data from a shared dictionary JSON (e.g., pulling GPU data from a SoC profile). If a sub-component relies on Type B, it imports both the physical value *and* the subscore logic natively.

**Example: GPU Architecture in a Phone JSON pulling from SoC JSON**
```json
"gpu_architecture": {
  "reference_id": "soc_snapdragon_8_gen_3",
  "target_field": "6_3_gpu_performance.gpu_architecture",
  "value": "Adreno 750",   // Imported context
  "subscore": 10.0         // Imported evaluation
}
```

### 3.3 Type C: Architectural Mapping (Updated)
Type C asserts that a component is physically identical to a previously reviewed device. If Type C is used at the *sub-component* level (e.g., "Ultrawide sensor is identical to Phone X"), it imports the subscore directly.
```json
"ultrawide_sensor_size": {
  "mapped_to": "apple_iphone_15_pro_max",
  "justification": "Identical 12MP 1/2.55\" ultrawide module confirmed by iFixit teardown",
  "subscore": 8.5
}
```

## 4. Securing the "Value" Field
Even with the `"subscore"` field resolving the mathematical tracking, we must still ruthlessly police the `"value"` field so it never devolves into `is_supported: true` again. The `"value"` must strictly take one of these physical data shapes:
1. **Continuous Numeric** (e.g., `167` for weight)
2. **Discrete Integer** (e.g., `2` for speaker count)
3. **Categorical String** (e.g., `"ProRes 4K60"`, `"Glass Front"`. If absent: `"None"`)
4. **String Array** (e.g., `["LDAC", "aptX HD"]`)
5. **Pure Boolean** (Restricted to generic presence without class, e.g., `"3_5mm_audio_jack": false`)

## 5. Conclusion
By introducing the `"subscore"` field into Types A, B, and C, we bridge the gap between "dumb data" and "the real scores". The JSON becomes completely self-documenting:
1. **Value** proves *What it is*.
2. **Subscore** proves *How this specific line-item scored*.
3. **Predicted/Final Score** proves *How the subsection performed as a whole*.

If you approve of this architectural upgrade, I will execute the rewrite of `data_structure_guidelines.md` to formalize `"subscore"`, and clean up `proposed_data_structure.md` to reflect this perfectly transparent, logic-friendly design.
